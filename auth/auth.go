package auth

import (
	"fmt"
	"github.com/MicahParks/keyfunc/v3"
	"github.com/golang-jwt/jwt/v5"
	"github.com/kobble-io/go-admin/utils"
	"strings"
	"time"
)

type KobbleAuth struct {
	issuer       string
	projectCache *utils.Cache[projectCache]
	config       Config
}

func NewKobbleAuth(conf Config) *KobbleAuth {
	defaultTtl := 50 * time.Minute / time.Second
	return &KobbleAuth{
		issuer: "https://kobble.io",
		projectCache: utils.NewCache[projectCache](utils.CacheConfig{
			DefaultTtl: &defaultTtl,
		}),
		config: conf,
	}
}

func (auth KobbleAuth) getProjectId() (string, error) {
	cacheProject := auth.projectCache.Get("default")
	if cacheProject != nil {
		return cacheProject.ProjectID, nil
	}

	var whoami Whoami
	err := auth.config.Http.GetJson("/auth/whoami", nil, &whoami)
	if err != nil {
		return "", err
	}

	auth.projectCache.Set("projectId", projectCache{ProjectID: whoami.ProjectId}, nil)
	return whoami.ProjectId, nil
}

// VerifyAccessToken verify an Access Token generated by your OAuth Application or throw an error.
// This method will verify the token signature and expiration time.
// It will also verify the issuer.
// By default, it will accept any audience (any OAuth application of your Kobble project).
// If you want to restrict the audience, you can pass the applicationId in the options.
//
//   - @param tokenString - The access token string to verify.
func (auth KobbleAuth) VerifyAccessToken(token string) (VerifyAccessTokenResult, error) {
	var result VerifyAccessTokenResult
	projectId, err := auth.getProjectId()
	if err != nil {
		return result, newAccessTokenVerificationError(err)
	}

	jwksURL := fmt.Sprintf("%s/discovery/p/%s/apps/keys", auth.config.BaseURL, projectId)
	k, err := keyfunc.NewDefault([]string{jwksURL})
	if err != nil {
		return VerifyAccessTokenResult{}, newAccessTokenVerificationError(err)
	}

	var rawClaims rawAccessTokenPayloadClaims
	tk, err := jwt.ParseWithClaims(token, &rawClaims, k.Keyfunc)
	if err != nil {
		return VerifyAccessTokenResult{}, newAccessTokenVerificationError(err)
	}

	if claims, ok := tk.Claims.(*rawAccessTokenPayloadClaims); ok && tk.Valid {
		return VerifyAccessTokenResult{
			UserID:    claims.Sub,
			ProjectID: claims.ProjectID,
			Claims:    *claims,
		}, nil
	}

	return VerifyAccessTokenResult{}, newAccessTokenVerificationError(fmt.Errorf("invalid token"))
}

func parseClaimsDate(date string) (string, error) {
	parseFormat := "Mon Jan 2 2006 15:04:05 GMT-0700"
	parsed, err := time.Parse(parseFormat, strings.Replace(date, " (Coordinated Universal Time)", "", 1))
	if err != nil {
		return "", fmt.Errorf("failed to parse date: %w", err)
	}

	return parsed.Format(time.RFC3339), nil
}

// VerifyIdToken verify an ID Token generated by your OAuth Application or throw an error.
// This method will verify the token signature and expiration time.
// It will also verify the issuer.
// By default, it will accept any audience (any OAuth application of your Kobble project).
// If you want to restrict the audience, you can pass the applicationId in the options.
//
//   - @param tokenString - The access token string to verify.
func (auth KobbleAuth) VerifyIdToken(token string) (VerifyIdTokenResult, error) {
	var result VerifyIdTokenResult
	projectId, err := auth.getProjectId()
	if err != nil {
		return result, newIdTokenVerificationError(err)
	}

	jwksURL := fmt.Sprintf("%s/discovery/p/%s/apps/keys", auth.config.BaseURL, projectId)
	k, err := keyfunc.NewDefault([]string{jwksURL})
	if err != nil {
		return VerifyIdTokenResult{}, newIdTokenVerificationError(err)
	}

	var rawClaims rawIdTokenPayloadClaims
	tk, err := jwt.ParseWithClaims(token, &rawClaims, k.Keyfunc)
	if err != nil {
		return VerifyIdTokenResult{}, newIdTokenVerificationError(err)
	}

	if claims, ok := tk.Claims.(*rawIdTokenPayloadClaims); ok && tk.Valid {
		updatedAt, err := parseClaimsDate(claims.UpdatedAt)
		if err != nil {
			return VerifyIdTokenResult{}, newIdTokenVerificationError(err)
		}

		createdAt, err := parseClaimsDate(claims.CreatedAt)
		if err != nil {
			return VerifyIdTokenResult{}, newIdTokenVerificationError(err)
		}

		return VerifyIdTokenResult{
			UserID: claims.Sub,
			User: idTokenUser{
				ID:         claims.ID,
				Email:      claims.Email,
				Name:       claims.Name,
				PictureURL: claims.PictureURL,
				IsVerified: claims.IsVerified,
				StripeID:   claims.StripeID,
				UpdatedAt:  updatedAt,
				CreatedAt:  createdAt,
			},
			Claims: *claims,
		}, nil
	}

	return VerifyIdTokenResult{}, newIdTokenVerificationError(fmt.Errorf("invalid token"))
}
